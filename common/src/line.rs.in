#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BufferLine {
    /// Unix timestamp for this line.
    time: i64,
    pub data: LineData,
}

impl BufferLine {
    pub fn new(time: Tm, data: LineData) -> Self {
        BufferLine {
            time: time.to_timespec().sec,
            data: data,
        }
    }

    pub fn time(&self) -> Tm {
        time::at(Timespec::new(self.time, 0))
    }

    /// True if this line pinged the user.
    pub fn has_ping(&self) -> bool {
        if let LineData::Message { ping, .. } = self.data {
            ping
        } else { false }
    }
}

fn is_false(v: &bool) -> bool {
    !v
}

fn const_false() -> bool {
    false
}


#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum LineData {
    Message {
        kind: MsgKind,
        from: String,
        msg: String,
        /// True if this message is marked as including a mention of the user's
        /// nick. This results in the client alerting the user to the message.
        #[serde(default="const_false")]
        ping: bool,
    },
    Topic {
        by: Option<String>,
        topic: String
    },
    Join {
        user: User,
    },
    Part {
        user: User,
        reason: String,
    },
    Kick {
        by: User,
        user: String,
        reason: String,
    },
    Quit {
        user: User,
        msg: Option<String>,
    },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MsgKind {
    PrivMsg,
    Notice,
    // FIXME: The below is not encodable
    // /// IRC response codes
    // Response(Response),
    /// Special status messages
    Status,
}

/// Sender of a message
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum Sender {
    User(User),
    Server(String),
}

/// An IRC user sender
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct User {
    pub nick: String,
    pub ident: String,
    pub host: String,
}
